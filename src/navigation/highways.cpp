#include "navigation/highways.h"
#include <stdbool.h>
#include <stdio.h>
#include <math.h>
#include "utils/logger.hpp"

// Autogenerated constants by obj_to_highways.py script
#define HIGHWAY_POINTS_COUNT 1188
#define HIGHWAY_LINES_COUNT 1288
static highway_point points[] = {{0, 0},{1, 0},{1, 1},{1, 1},{1, 0},{1, 0},{1, -1},{1, -1},{0, -1},{0, -1},{1, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{1, 0},{0, 0},{0, 0},{0, 0},{0, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 1},{1, 1},{1, 1},{1, 1},{1, 1},{1, 1},{1, 1},{1, 1},{1, 1},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{1, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, -1},{0, -1},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, -1},{0, -1},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{1, 1},{1, 1},{1, 1},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, -1},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, -1},{1, -1},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, -1},{1, -1},{1, 0},{1, 0},{1, 0},{1, -1},{1, -1},{1, -1},{0, -1},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{0, -1},{0, -1},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{0, 0},{0, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{0, 0},{0, 0},{0, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{0, 0},{0, 0},{1, 1},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{1, -1},{1, -1},{1, -1},{1, 0},{1, 0},{1, 0},{1, 0},{1, 1},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{0, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, -1},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{1, 0},{-1, 0},{-1, 1},{-1, 1},{-1, 0},{-1, 0},{-1, -1},{-1, -1},{0, -1},{0, -1},{-1, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{-1, 0},{0, 0},{0, 0},{0, 0},{0, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 1},{-1, 1},{-1, 1},{-1, 1},{-1, 1},{-1, 1},{-1, 1},{-1, 1},{-1, 1},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{-1, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, -1},{0, -1},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{-1, 1},{-1, 1},{-1, 1},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, -1},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, -1},{-1, -1},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, -1},{-1, -1},{-1, 0},{-1, 0},{-1, 0},{-1, -1},{-1, -1},{-1, -1},{0, -1},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{0, -1},{0, -1},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{0, 0},{0, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{0, 0},{0, 0},{0, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{0, 0},{0, 0},{-1, 1},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, -1},{0, -1},{0, -1},{0, -1},{0, -1},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{0, 0},{-1, -1},{-1, -1},{-1, -1},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 1},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{0, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, -1},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},};
static highway_line lines[] = {{0, 34},{34, 35},{35, 36},{36, 37},{37, 38},{38, 39},{39, 40},{40, 1},{1, 41},{41, 42},{42, 43},{43, 44},{44, 45},{45, 46},{46, 47},{47, 2},{2, 48},{48, 49},{49, 50},{50, 51},{51, 52},{52, 53},{53, 54},{54, 3},{3, 55},{55, 56},{56, 57},{57, 58},{58, 59},{59, 60},{60, 61},{61, 4},{4, 62},{62, 63},{63, 64},{64, 65},{65, 66},{66, 67},{67, 68},{68, 5},{5, 69},{69, 70},{70, 71},{71, 72},{72, 73},{73, 74},{74, 75},{75, 6},{6, 76},{76, 77},{77, 78},{78, 79},{79, 80},{80, 81},{81, 82},{82, 7},{7, 83},{83, 84},{84, 85},{85, 86},{86, 87},{87, 88},{88, 89},{89, 8},{8, 90},{90, 91},{91, 92},{92, 93},{93, 94},{94, 95},{95, 96},{96, 9},{9, 97},{97, 98},{98, 99},{99, 100},{100, 101},{101, 102},{102, 103},{103, 10},{7, 104},{104, 105},{105, 106},{106, 107},{107, 108},{108, 109},{109, 110},{110, 10},{6, 111},{111, 112},{112, 113},{113, 114},{114, 115},{115, 116},{116, 117},{117, 10},{7, 118},{118, 119},{119, 120},{120, 121},{121, 122},{122, 123},{123, 124},{124, 9},{8, 125},{125, 126},{126, 127},{127, 128},{128, 129},{129, 130},{130, 131},{131, 10},{9, 132},{132, 133},{133, 134},{134, 135},{135, 136},{136, 137},{137, 138},{138, 11},{11, 139},{139, 140},{140, 141},{141, 142},{142, 143},{143, 144},{144, 145},{145, 12},{13, 146},{146, 147},{147, 148},{148, 149},{149, 150},{150, 151},{151, 152},{152, 14},{12, 153},{153, 154},{154, 155},{155, 156},{156, 157},{157, 158},{158, 159},{159, 14},{13, 160},{160, 161},{161, 162},{162, 163},{163, 164},{164, 165},{165, 166},{166, 11},{8, 167},{167, 168},{168, 169},{169, 170},{170, 171},{171, 172},{172, 173},{173, 13},{15, 174},{174, 175},{175, 176},{176, 177},{177, 178},{178, 179},{179, 180},{180, 16},{12, 181},{181, 182},{182, 183},{183, 184},{184, 185},{185, 186},{186, 187},{187, 15},{16, 188},{188, 189},{189, 190},{190, 191},{191, 192},{192, 193},{193, 194},{194, 14},{18, 195},{195, 196},{196, 197},{197, 198},{198, 199},{199, 200},{200, 201},{201, 19},{17, 202},{202, 203},{203, 204},{204, 205},{205, 206},{206, 207},{207, 208},{208, 18},{20, 209},{209, 210},{210, 211},{211, 212},{212, 213},{213, 214},{214, 215},{215, 19},{16, 216},{216, 217},{217, 218},{218, 219},{219, 220},{220, 221},{221, 222},{222, 20},{19, 223},{223, 224},{224, 225},{225, 226},{226, 227},{227, 228},{228, 229},{229, 14},{13, 230},{230, 231},{231, 232},{232, 233},{233, 234},{234, 235},{235, 236},{236, 18},{17, 237},{237, 238},{238, 239},{239, 240},{240, 241},{241, 242},{242, 243},{243, 8},{22, 244},{244, 245},{245, 246},{246, 247},{247, 248},{248, 249},{249, 250},{250, 23},{21, 251},{251, 252},{252, 253},{253, 254},{254, 255},{255, 256},{256, 257},{257, 22},{24, 258},{258, 259},{259, 260},{260, 261},{261, 262},{262, 263},{263, 264},{264, 23},{20, 265},{265, 266},{266, 267},{267, 268},{268, 269},{269, 270},{270, 271},{271, 24},{23, 272},{272, 273},{273, 274},{274, 275},{275, 276},{276, 277},{277, 278},{278, 19},{18, 279},{279, 280},{280, 281},{281, 282},{282, 283},{283, 284},{284, 285},{285, 22},{21, 286},{286, 287},{287, 288},{288, 289},{289, 290},{290, 291},{291, 292},{292, 17},{26, 293},{293, 294},{294, 295},{295, 296},{296, 297},{297, 298},{298, 299},{299, 27},{25, 300},{300, 301},{301, 302},{302, 303},{303, 304},{304, 305},{305, 306},{306, 26},{28, 307},{307, 308},{308, 309},{309, 310},{310, 311},{311, 312},{312, 313},{313, 27},{24, 314},{314, 315},{315, 316},{316, 317},{317, 318},{318, 319},{319, 320},{320, 28},{27, 321},{321, 322},{322, 323},{323, 324},{324, 325},{325, 326},{326, 327},{327, 23},{22, 328},{328, 329},{329, 330},{330, 331},{331, 332},{332, 333},{333, 334},{334, 26},{25, 335},{335, 336},{336, 337},{337, 338},{338, 339},{339, 340},{340, 341},{341, 21},{30, 342},{342, 343},{343, 344},{344, 345},{345, 346},{346, 347},{347, 348},{348, 31},{29, 349},{349, 350},{350, 351},{351, 352},{352, 353},{353, 354},{354, 355},{355, 30},{32, 356},{356, 357},{357, 358},{358, 359},{359, 360},{360, 361},{361, 362},{362, 31},{28, 363},{363, 364},{364, 365},{365, 366},{366, 367},{367, 368},{368, 369},{369, 32},{31, 370},{370, 371},{371, 372},{372, 373},{373, 374},{374, 375},{375, 376},{376, 27},{26, 377},{377, 378},{378, 379},{379, 380},{380, 381},{381, 382},{382, 383},{383, 30},{29, 384},{384, 385},{385, 386},{386, 387},{387, 388},{388, 389},{389, 390},{390, 25},{2, 391},{391, 392},{392, 393},{393, 394},{394, 395},{395, 396},{396, 397},{397, 29},{1, 398},{398, 399},{399, 400},{400, 401},{401, 402},{402, 403},{403, 404},{404, 25},{1, 405},{405, 406},{406, 407},{407, 408},{408, 409},{409, 410},{410, 411},{411, 29},{1, 412},{412, 413},{413, 414},{414, 415},{415, 416},{416, 417},{417, 418},{418, 4},{1, 419},{419, 420},{420, 421},{421, 422},{422, 423},{423, 424},{424, 425},{425, 5},{21, 426},{426, 427},{427, 428},{428, 429},{429, 430},{430, 431},{431, 432},{432, 33},{1, 433},{433, 434},{434, 435},{435, 436},{436, 437},{437, 438},{438, 439},{439, 33},{4, 440},{440, 441},{441, 442},{442, 443},{443, 444},{444, 445},{445, 446},{446, 33},{17, 447},{447, 448},{448, 449},{449, 450},{450, 451},{451, 452},{452, 453},{453, 33},{25, 454},{454, 455},{455, 456},{456, 457},{457, 458},{458, 459},{459, 460},{460, 33},{7, 461},{461, 462},{462, 463},{463, 464},{464, 465},{465, 466},{466, 467},{467, 21},{5, 468},{468, 469},{469, 470},{470, 471},{471, 472},{472, 473},{473, 474},{474, 7},{5, 475},{475, 476},{476, 477},{477, 478},{478, 479},{479, 480},{480, 481},{481, 8},{5, 482},{482, 483},{483, 484},{484, 485},{485, 486},{486, 487},{487, 488},{488, 11},{5, 489},{489, 490},{490, 491},{491, 492},{492, 493},{493, 494},{494, 495},{495, 14},{5, 496},{496, 497},{497, 498},{498, 499},{499, 500},{500, 501},{501, 502},{502, 23},{5, 503},{503, 504},{504, 505},{505, 506},{506, 507},{507, 508},{508, 509},{509, 17},{5, 510},{510, 511},{511, 512},{512, 513},{513, 514},{514, 515},{515, 516},{516, 20},{4, 517},{517, 518},{518, 519},{519, 520},{520, 521},{521, 522},{522, 523},{523, 27},{2, 524},{524, 525},{525, 526},{526, 527},{527, 528},{528, 529},{529, 530},{530, 25},{25, 531},{531, 532},{532, 533},{533, 534},{534, 535},{535, 536},{536, 537},{537, 31},{28, 538},{538, 539},{539, 540},{540, 541},{541, 542},{542, 543},{543, 544},{544, 29},{24, 545},{545, 546},{546, 547},{547, 548},{548, 549},{549, 550},{550, 551},{551, 25},{8, 552},{552, 553},{553, 554},{554, 555},{555, 556},{556, 557},{557, 558},{558, 24},{15, 559},{559, 560},{560, 561},{561, 562},{562, 563},{563, 564},{564, 565},{565, 17},{21, 566},{566, 567},{567, 568},{568, 569},{569, 570},{570, 571},{571, 572},{572, 28},{6, 573},{573, 574},{574, 575},{575, 576},{576, 577},{577, 578},{578, 579},{579, 21},{3, 580},{580, 581},{581, 582},{582, 583},{583, 584},{584, 585},{585, 586},{586, 25},{3, 587},{587, 588},{588, 589},{589, 590},{590, 591},{591, 592},{592, 593},{593, 22},{3, 594},{594, 595},{595, 596},{596, 597},{597, 598},{598, 599},{599, 600},{600, 33},{5, 601},{601, 602},{602, 603},{603, 604},{604, 605},{605, 606},{606, 607},{607, 33},{7, 608},{608, 609},{609, 610},{610, 611},{611, 612},{612, 613},{613, 614},{614, 33},{0, 642},{642, 643},{643, 644},{644, 645},{645, 646},{646, 647},{647, 648},{648, 615},{615, 649},{649, 650},{650, 651},{651, 652},{652, 653},{653, 654},{654, 655},{655, 616},{616, 656},{656, 657},{657, 658},{658, 659},{659, 660},{660, 661},{661, 662},{662, 617},{617, 663},{663, 664},{664, 665},{665, 666},{666, 667},{667, 668},{668, 669},{669, 618},{618, 670},{670, 671},{671, 672},{672, 673},{673, 674},{674, 675},{675, 676},{676, 619},{619, 677},{677, 678},{678, 679},{679, 680},{680, 681},{681, 682},{682, 683},{683, 620},{620, 684},{684, 685},{685, 686},{686, 687},{687, 688},{688, 689},{689, 690},{690, 621},{621, 691},{691, 692},{692, 693},{693, 694},{694, 695},{695, 696},{696, 697},{697, 622},{622, 698},{698, 699},{699, 700},{700, 701},{701, 702},{702, 703},{703, 704},{704, 623},{623, 705},{705, 706},{706, 707},{707, 708},{708, 709},{709, 710},{710, 711},{711, 624},{621, 712},{712, 713},{713, 714},{714, 715},{715, 716},{716, 717},{717, 718},{718, 624},{620, 719},{719, 720},{720, 721},{721, 722},{722, 723},{723, 724},{724, 725},{725, 624},{621, 726},{726, 727},{727, 728},{728, 729},{729, 730},{730, 731},{731, 732},{732, 623},{622, 733},{733, 734},{734, 735},{735, 736},{736, 737},{737, 738},{738, 739},{739, 624},{623, 740},{740, 741},{741, 742},{742, 743},{743, 744},{744, 745},{745, 746},{746, 625},{625, 747},{747, 748},{748, 749},{749, 750},{750, 751},{751, 752},{752, 753},{753, 626},{627, 754},{754, 755},{755, 756},{756, 757},{757, 758},{758, 759},{759, 760},{760, 628},{626, 761},{761, 762},{762, 763},{763, 764},{764, 765},{765, 766},{766, 767},{767, 628},{627, 768},{768, 769},{769, 770},{770, 771},{771, 772},{772, 773},{773, 774},{774, 625},{622, 775},{775, 776},{776, 777},{777, 778},{778, 779},{779, 780},{780, 781},{781, 627},{626, 782},{782, 783},{783, 784},{784, 785},{785, 786},{786, 787},{787, 788},{788, 15},{16, 789},{789, 790},{790, 791},{791, 792},{792, 793},{793, 794},{794, 795},{795, 628},{630, 796},{796, 797},{797, 798},{798, 799},{799, 800},{800, 801},{801, 802},{802, 631},{629, 803},{803, 804},{804, 805},{805, 806},{806, 807},{807, 808},{808, 809},{809, 630},{20, 810},{810, 811},{811, 812},{812, 813},{813, 814},{814, 815},{815, 816},{816, 631},{631, 817},{817, 818},{818, 819},{819, 820},{820, 821},{821, 822},{822, 823},{823, 628},{627, 824},{824, 825},{825, 826},{826, 827},{827, 828},{828, 829},{829, 830},{830, 630},{629, 831},{831, 832},{832, 833},{833, 834},{834, 835},{835, 836},{836, 837},{837, 622},{633, 838},{838, 839},{839, 840},{840, 841},{841, 842},{842, 843},{843, 844},{844, 634},{632, 845},{845, 846},{846, 847},{847, 848},{848, 849},{849, 850},{850, 851},{851, 633},{24, 852},{852, 853},{853, 854},{854, 855},{855, 856},{856, 857},{857, 858},{858, 634},{634, 859},{859, 860},{860, 861},{861, 862},{862, 863},{863, 864},{864, 865},{865, 631},{630, 866},{866, 867},{867, 868},{868, 869},{869, 870},{870, 871},{871, 872},{872, 633},{632, 873},{873, 874},{874, 875},{875, 876},{876, 877},{877, 878},{878, 879},{879, 629},{636, 880},{880, 881},{881, 882},{882, 883},{883, 884},{884, 885},{885, 886},{886, 637},{635, 887},{887, 888},{888, 889},{889, 890},{890, 891},{891, 892},{892, 893},{893, 636},{28, 894},{894, 895},{895, 896},{896, 897},{897, 898},{898, 899},{899, 900},{900, 637},{637, 901},{901, 902},{902, 903},{903, 904},{904, 905},{905, 906},{906, 907},{907, 634},{633, 908},{908, 909},{909, 910},{910, 911},{911, 912},{912, 913},{913, 914},{914, 636},{635, 915},{915, 916},{916, 917},{917, 918},{918, 919},{919, 920},{920, 921},{921, 632},{639, 922},{922, 923},{923, 924},{924, 925},{925, 926},{926, 927},{927, 928},{928, 640},{638, 929},{929, 930},{930, 931},{931, 932},{932, 933},{933, 934},{934, 935},{935, 639},{32, 936},{936, 937},{937, 938},{938, 939},{939, 940},{940, 941},{941, 942},{942, 640},{640, 943},{943, 944},{944, 945},{945, 946},{946, 947},{947, 948},{948, 949},{949, 637},{636, 950},{950, 951},{951, 952},{952, 953},{953, 954},{954, 955},{955, 956},{956, 639},{638, 957},{957, 958},{958, 959},{959, 960},{960, 961},{961, 962},{962, 963},{963, 635},{616, 964},{964, 965},{965, 966},{966, 967},{967, 968},{968, 969},{969, 970},{970, 638},{615, 971},{971, 972},{972, 973},{973, 974},{974, 975},{975, 976},{976, 977},{977, 635},{615, 978},{978, 979},{979, 980},{980, 981},{981, 982},{982, 983},{983, 984},{984, 638},{615, 985},{985, 986},{986, 987},{987, 988},{988, 989},{989, 990},{990, 991},{991, 618},{615, 992},{992, 993},{993, 994},{994, 995},{995, 996},{996, 997},{997, 998},{998, 619},{632, 999},{999, 1000},{1000, 1001},{1001, 1002},{1002, 1003},{1003, 1004},{1004, 1005},{1005, 641},{615, 1006},{1006, 1007},{1007, 1008},{1008, 1009},{1009, 1010},{1010, 1011},{1011, 1012},{1012, 641},{618, 1013},{1013, 1014},{1014, 1015},{1015, 1016},{1016, 1017},{1017, 1018},{1018, 1019},{1019, 641},{629, 1020},{1020, 1021},{1021, 1022},{1022, 1023},{1023, 1024},{1024, 1025},{1025, 1026},{1026, 641},{635, 1027},{1027, 1028},{1028, 1029},{1029, 1030},{1030, 1031},{1031, 1032},{1032, 1033},{1033, 641},{621, 1034},{1034, 1035},{1035, 1036},{1036, 1037},{1037, 1038},{1038, 1039},{1039, 1040},{1040, 632},{619, 1041},{1041, 1042},{1042, 1043},{1043, 1044},{1044, 1045},{1045, 1046},{1046, 1047},{1047, 621},{619, 1048},{1048, 1049},{1049, 1050},{1050, 1051},{1051, 1052},{1052, 1053},{1053, 1054},{1054, 622},{619, 1055},{1055, 1056},{1056, 1057},{1057, 1058},{1058, 1059},{1059, 1060},{1060, 1061},{1061, 625},{619, 1062},{1062, 1063},{1063, 1064},{1064, 1065},{1065, 1066},{1066, 1067},{1067, 1068},{1068, 628},{619, 1069},{1069, 1070},{1070, 1071},{1071, 1072},{1072, 1073},{1073, 1074},{1074, 1075},{1075, 634},{619, 1076},{1076, 1077},{1077, 1078},{1078, 1079},{1079, 1080},{1080, 1081},{1081, 1082},{1082, 629},{619, 1083},{1083, 1084},{1084, 1085},{1085, 1086},{1086, 1087},{1087, 1088},{1088, 1089},{1089, 20},{618, 1090},{1090, 1091},{1091, 1092},{1092, 1093},{1093, 1094},{1094, 1095},{1095, 1096},{1096, 637},{616, 1097},{1097, 1098},{1098, 1099},{1099, 1100},{1100, 1101},{1101, 1102},{1102, 1103},{1103, 635},{635, 1104},{1104, 1105},{1105, 1106},{1106, 1107},{1107, 1108},{1108, 1109},{1109, 1110},{1110, 640},{28, 1111},{1111, 1112},{1112, 1113},{1113, 1114},{1114, 1115},{1115, 1116},{1116, 1117},{1117, 638},{24, 1118},{1118, 1119},{1119, 1120},{1120, 1121},{1121, 1122},{1122, 1123},{1123, 1124},{1124, 635},{622, 1125},{1125, 1126},{1126, 1127},{1127, 1128},{1128, 1129},{1129, 1130},{1130, 1131},{1131, 24},{15, 1132},{1132, 1133},{1133, 1134},{1134, 1135},{1135, 1136},{1136, 1137},{1137, 1138},{1138, 629},{632, 1139},{1139, 1140},{1140, 1141},{1141, 1142},{1142, 1143},{1143, 1144},{1144, 1145},{1145, 28},{620, 1146},{1146, 1147},{1147, 1148},{1148, 1149},{1149, 1150},{1150, 1151},{1151, 1152},{1152, 632},{617, 1153},{1153, 1154},{1154, 1155},{1155, 1156},{1156, 1157},{1157, 1158},{1158, 1159},{1159, 635},{617, 1160},{1160, 1161},{1161, 1162},{1162, 1163},{1163, 1164},{1164, 1165},{1165, 1166},{1166, 633},{617, 1167},{1167, 1168},{1168, 1169},{1169, 1170},{1170, 1171},{1171, 1172},{1172, 1173},{1173, 641},{619, 1174},{1174, 1175},{1175, 1176},{1176, 1177},{1177, 1178},{1178, 1179},{1179, 1180},{1180, 641},{621, 1181},{1181, 1182},{1182, 1183},{1183, 1184},{1184, 1185},{1185, 1186},{1186, 1187},{1187, 641},};

// Graph structure for search algorithm
static int graph[HIGHWAY_POINTS_COUNT][HIGHWAY_POINTS_COUNT]; // indexes of highways
static int highway_cost[HIGHWAY_LINES_COUNT];


//Internal Prototypes
double distance(highway_point a, highway_point b);
double point_to_segment_distance(highway_point p, highway_point v, highway_point w);
bool is_point_in_rectangle(highway_point p, highway_line * line);
bool does_circle_touch_highway(highway_obstruction_object circle, highway_line * line);
bool does_square_touch_highway(highway_obstruction_object square, highway_line * line);
bool does_rectangle_touch_highway(highway_obstruction_object rectangle, highway_line * line);
void get_available_highways(bool av_highways_arr[]);
bool any_obstacle_on_highway(highway_line * line);
bool obstacle_on_highway(highway_obstruction_object* obs, highway_line * line);

//These are all of the objects
highway_obstruction_object obs_obj_stocks[STOCK_COUNT];
highway_obstruction_object obs_obj_opponent = 
    {{500, 0}, true, 150, 0, highway_obstruction_object_type::Circle};

void to_json(json& j, const highway_point& p){
    j = json{
        {"x", p.x},
        {"y", p.y},
    };
}
void to_json(json& j, const highway_line& p){
    j = json{
        {"a", p.a},
        {"b", p.b},
    };
}
void to_json(json& j, const highway_obstruction_object& p){
    j = json{
        {"pos", p.pos},
        {"present", p.present},
        {"size", p.size},
        {"size2", p.size2},
        {"type", p.type},
    };
}

void highway_segments_json(json& j){
    j = json::array();
    highway_point * a;
    highway_point * b;
    bool avail_highw[HIGHWAY_LINES_COUNT];
    get_available_highways(avail_highw);
    for (int i = 0; i < HIGHWAY_LINES_COUNT; i++){
        a = points + lines[i].a;
        b = points + lines[i].b;
        j.push_back({{"ax", a->x}, {"ay", a->y}, {"bx", b->x}, {"by", b->y}, {"available", avail_highw[i] ? "true" : "false"}});
    }
}
void highway_obstacles_json(json& j){
    j = json::array();
    for(int stock_i = 0; stock_i < STOCK_COUNT; stock_i++){
        j.push_back(obs_obj_stocks[stock_i]);
    }
    j.push_back(obs_obj_opponent);
}

// Function to calculate the angle ABC in degrees
double calculate_angle(highway_point A, highway_point B, highway_point C) {
    // Calculate vectors AB and BC
    double ABx = B.x - A.x;
    double ABy = B.y - A.y;
    double BCx = C.x - B.x;
    double BCy = C.y - B.y;

    // Calculate dot product and magnitudes of AB and BC
    double dot_product = ABx * BCx + ABy * BCy;
    double magnitude_AB = sqrt(ABx * ABx + ABy * ABy);
    double magnitude_BC = sqrt(BCx * BCx + BCy * BCy);

    // Calculate the cosine of the angle
    double cos_theta = dot_product / (magnitude_AB * magnitude_BC);

    // Clamp the value of cos_theta to avoid floating-point issues
    if (cos_theta > 1.0) cos_theta = 1.0;
    if (cos_theta < -1.0) cos_theta = -1.0;

    // Calculate the angle in radians and convert to degrees
    double angle_rad = acos(cos_theta);
    double angle_deg = angle_rad * RAD_TO_DEG;

    return angle_deg;
}

//takes in point indexes
int additionnal_turn_cost(int start, int middle, int end){
    //Lets say that turning costs 500mm + 1mm/deg
    double angle = abs(calculate_angle(points[start], points[middle], points[end]));
    if (angle > 175)
        return 0;
    return ((int)(180 - angle) + 500);
}

// Function to find the shortest path using Dijkstra's algorithm
// Returns the number of points in result[]. If error, returns 0
int dijkstra(int source, int destination, bool available_highways[], highway_point result[]) {
    int dist[HIGHWAY_POINTS_COUNT], visited[HIGHWAY_POINTS_COUNT];
    int prev[HIGHWAY_POINTS_COUNT];

    for (int i = 0; i < HIGHWAY_POINTS_COUNT; i++) {
        dist[i] = INF;
        visited[i] = 0;
        prev[i] = -1;
    }

    dist[source] = 0;

    for (int i = 0; i < HIGHWAY_POINTS_COUNT - 1; i++) {
        int min_dist = INF, u = -1;

        for (int v = 0; v < HIGHWAY_POINTS_COUNT; v++) {
            if (!visited[v] && dist[v] < min_dist) {
                min_dist = dist[v];
                u = v;
            }
        }

        if (u == -1 || u == destination) break;

        visited[u] = 1;

        for (int v = 0; v < HIGHWAY_POINTS_COUNT; v++) {
            if (!visited[v] && graph[u][v] != -1 && prev[u] != v && available_highways[graph[u][v]]) {
                int cost = highway_cost[graph[u][v]];
                int additional_cost = (prev[u] != -1) ? additionnal_turn_cost(prev[u], u, v) : 0; // Add turn cost if applicable
                if (dist[u] + cost + additional_cost < dist[v]) {
                    dist[v] = dist[u] + cost + additional_cost;
                    prev[v] = u;
                }
            }
        }
    }

    if (dist[destination] == INF) {
        LOG_INFO("No path exists between the points.");
        return 0;
    }

    LOG_INFO("Shortest path time: ", dist[destination]);
    LOG_INFO("Path: ");

    int path[HIGHWAY_POINTS_COUNT], path_length = 0;
    for (int at = destination; at != -1; at = prev[at]) {
        path[path_length++] = at;
    }

    for (int i = path_length - 1; i >= 0; i--) {
        std::cout << path[i] << ((i > 0) ? " -> " : "\n");
        result[i] = points[path[ path_length - 1 - i ]];
    }
    return path_length;
}


void init_highways(){
    for (int i = 0; i < HIGHWAY_POINTS_COUNT; i++) {
        for (int j = 0; j < HIGHWAY_POINTS_COUNT; j++) {
            graph[i][j] = -1;
        }
    }
    for (int i = 0; i < HIGHWAY_LINES_COUNT; i++) {
        highway_point * A = points + lines[i].a;
        highway_point * B = points + lines[i].b;
        double travel_time = distance(*A, *B);
        graph[lines[i].a][lines[i].b] = i;
        graph[lines[i].b][lines[i].a] = i; // Highways are bidirectional
        highway_cost[i] = (int)travel_time;
    }
    for (int i = 0; i < STOCK_COUNT; i++){
        highway_point p;
        p.x = STOCK_POSITION_ARRAY[i].x;
        p.y = STOCK_POSITION_ARRAY[i].y;
        int w = STOCK_POSITION_ARRAY[i].theta == 90 ? 400 : 100;
        int h = STOCK_POSITION_ARRAY[i].theta == 90 ? 100 : 400;
        obs_obj_stocks[i] = {p, true, w, h, highway_obstruction_object_type::Rectangle};
    }
}
// Returns the number of points in result[]. If error, returns 0
// also adds target point at the end of result[]
int find_fastest_path(highway_point start, highway_point target, highway_point result[]){
    bool av_highways_arr[HIGHWAY_LINES_COUNT];
    get_available_highways(av_highways_arr);

    //TODO change this so it goes to the closes highway, not point, using the min distance to an highway
    int A = 0, B = 0;
    int min_start = INF, min_target = INF;
    for(int i = 0; i < HIGHWAY_POINTS_COUNT; i++){
        int dist_start = distance(start, points[i]);
        int dist_target = distance(target, points[i]);
        if (dist_start < min_start){
            min_start = dist_start;
            A = i;
        }
        if (dist_target < min_target){
            min_target = dist_target;
            B = i;
        }
    }
    // if the distance from start to target is less than min_target, then we can go directly to the target
    if (distance(start, target) < 1.5 * min_target){
        result[0] = target;
        return 1;
    }
    int res = dijkstra(A, B, av_highways_arr, result);
    if (res == 0)
        return 0;
    result[res] = target;
    return res+1;
}


bool unit_tests(){
    highway_point result[HIGHWAY_POINTS_COUNT+1];
    int res = find_fastest_path({-1100, 0}, {1100, 0}, result);
    if (res == 0){
        // No path found, obstacle was blocking
        LOG_DEBUG("Test 1 passed");
    }
    else{
        LOG_WARNING("Test 1 failed");
    }

    obs_obj_opponent.pos = {-500, 200+150+50};
    res = find_fastest_path({1100, 0}, {-1100, 0}, result);
    if (res != 0){
        // path found
        LOG_DEBUG("Test 2 passed");
    }
    else{
        LOG_WARNING("Test 2 failed");
    }
    return true;
}


// Fills the bool array, true if highway is available
void get_available_highways(bool av_highways_arr[]){
    for(int i = 0; i < HIGHWAY_LINES_COUNT; i++){
        av_highways_arr[i] = !any_obstacle_on_highway(lines + i);
    }
}

// Pointer to a line
bool any_obstacle_on_highway(highway_line * line){
    for(int stock_i = 0; stock_i < STOCK_COUNT; stock_i++){
        if (obstacle_on_highway(obs_obj_stocks + stock_i, line)) return true;
    }
    return (obstacle_on_highway(&obs_obj_opponent, line));
}

// takes a pointer to an obstruction object and a line
bool obstacle_on_highway(highway_obstruction_object* obs, highway_line * line){
    if (!obs->present)
        return false;
    switch (obs->type)
    {
    case highway_obstruction_object_type::Circle:
        return (does_circle_touch_highway(*obs, line));
    case highway_obstruction_object_type::Rectangle:
        return (does_rectangle_touch_highway(*obs, line));
    case highway_obstruction_object_type::Square:
        return (does_square_touch_highway(*obs, line));    
    default:
        LOG_ERROR("Not yet implemented obstacle type");
        return false;
        break;
    }
}




// Function to calculate the distance between two points
double inline distance(highway_point a, highway_point b) {
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

// Function to calculate the shortest distance from a point to a line segment
double point_to_segment_distance(highway_point p, highway_point v, highway_point w) {
    double l2 = distance(v, w) * distance(v, w);
    if (l2 == 0.0) return distance(p, v);

    double t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = fmax(0, fmin(1, t));

    highway_point projection = {
        .x = v.x + (int)(t * (w.x - v.x)),
        .y = v.y + (int)(t * (w.y - v.y))
    };

    return distance(p, projection);
}

// A utility function to get the maximum of two numbers
float max(float a, float b) { return a > b ? a : b; }

// A utility function to get the minimum of two numbers
float min(float a, float b) { return a < b ? a : b; }

// Function to check if two ranges [a1, a2] and [b1, b2] overlap
int isRangeOverlap(float a1, float a2, float b1, float b2) {
    return max(a1, a2) >= min(b1, b2) && min(a1, a2) <= max(b1, b2);
}

// Function to check if a point (px, py) lies inside the rectangle
int isPointInsideRectangle(float px, float py, float cx, float cy, float w, float h) {
    float left = cx - w / 2, right = cx + w / 2;
    float bottom = cy - h / 2, top = cy + h / 2;
    return (px >= left && px <= right && py >= bottom && py <= top);
}

// Function to compute orientation of ordered triplet (p, q, r)
// Returns 0 if collinear, 1 if clockwise, 2 if counterclockwise
int orientation(float px, float py, float qx, float qy, float rx, float ry) {
    float val = (qy - py) * (rx - qx) - (qx - px) * (ry - qy);
    if (val == 0) return 0; // Collinear
    return (val > 0) ? 1 : 2; // Clockwise or Counterclockwise
}

// Function to check if two segments (p1,q1) and (p2,q2) intersect
int doSegmentsIntersect(float p1x, float p1y, float q1x, float q1y,
                        float p2x, float p2y, float q2x, float q2y) {
    int o1 = orientation(p1x, p1y, q1x, q1y, p2x, p2y);
    int o2 = orientation(p1x, p1y, q1x, q1y, q2x, q2y);
    int o3 = orientation(p2x, p2y, q2x, q2y, p1x, p1y);
    int o4 = orientation(p2x, p2y, q2x, q2y, q1x, q1y);

    // General case
    if (o1 != o2 && o3 != o4) return 1;

    return 0; // Segments do not intersect
}

// Function to check if segment AB intersects with rectangle
bool doesSegmentIntersectRectangle(highway_point P1, highway_point P2,
                                  float cx, float cy, float w, float h) {
    // Rectangle corners
    float left = cx - w / 2, right = cx + w / 2;
    float bottom = cy - h / 2, top = cy + h / 2;

    // Check if either point A or B is inside the rectangle
    if (isPointInsideRectangle(P1.x, P1.y, cx, cy, w, h) ||
        isPointInsideRectangle(P2.x, P2.y, cx, cy, w, h)) {
        return true; // Segment starts or ends inside the rectangle
    }

    // Rectangle edges
    float rx1 = left, ry1 = bottom, rx2 = right, ry2 = bottom; // Bottom edge
    float rx3 = right, ry3 = bottom, rx4 = right, ry4 = top;   // Right edge
    float rx5 = right, ry5 = top, rx6 = left, ry6 = top;       // Top edge
    float rx7 = left, ry7 = top, rx8 = left, ry8 = bottom;     // Left edge

    // Check for intersection with each rectangle edge
    if (doSegmentsIntersect(P1.x, P1.y, P2.x, P2.y, rx1, ry1, rx2, ry2)) return true;
    if (doSegmentsIntersect(P1.x, P1.y, P2.x, P2.y, rx3, ry3, rx4, ry4)) return true;
    if (doSegmentsIntersect(P1.x, P1.y, P2.x, P2.y, rx5, ry5, rx6, ry6)) return true;
    if (doSegmentsIntersect(P1.x, P1.y, P2.x, P2.y, rx7, ry7, rx8, ry8)) return true;

    return false; // No intersection
}

// Function to check if a circular highway_obstruction_object touches or overlaps a rectangle
bool does_circle_touch_highway(highway_obstruction_object circle, highway_line * line) {
    if (point_to_segment_distance(circle.pos, points[line->a], points[line->b]) <= circle.size + ROBOT_WIDTH / 2) {
        return true;
    }
    return false; // The circle does not overlap the highway
}
// Function to check if a square highway_obstruction_object touches or overlaps a rectangle
bool does_square_touch_highway(highway_obstruction_object square, highway_line * line) {
    return doesSegmentIntersectRectangle(points[line->a], points[line->b], 
                                        square.pos.x, square.pos.y, square.size * 2 + ROBOT_WIDTH, square.size * 2 + ROBOT_WIDTH);
}
// Function to check if a rectangle highway_obstruction_object touches or overlaps a rectangle
bool does_rectangle_touch_highway(highway_obstruction_object rectangle, highway_line * line) {
    return doesSegmentIntersectRectangle(points[line->a], points[line->b], 
                                    rectangle.pos.x, rectangle.pos.y, rectangle.size * 2 + ROBOT_WIDTH, rectangle.size2 * 2 + ROBOT_WIDTH);
}